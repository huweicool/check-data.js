<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        const _toString = Object.prototype.toString;
        const isType = (value, type) => _toString.call(value) === '[object ' + type + ']';

        const isNull = value => isType(value, 'Null');
        const isUndefined = value => isType(value, 'Undefined');

        // string
        function trim(value) {
            if (!!String.prototype.trim) return value.trim();
            return value.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
        }
        const isString = value => isType(value, 'String');
        const isValidString = value => isString(value) && trim(value).length > 0;
        const isEmptyString = value => isString(value) && trim(value).length === 0;

        // boolean
        const isBoolean = value => isType(value, 'Boolean');
        const isTrue = value => isBoolean(value) && value === true;
        const isFalse = value => isBoolean(value) && value === false;

        // number
        const MaxNumber = Math.pow(2, 53) - 1;
        const isNumber = value => isType(value, 'Number');
        const isValidNumber = value => isNumber(value) && isFinite(value) && value < MaxNumber && value > -MaxNumber;

        // function
        const isGeneralFunction = value => isType(value, 'Function');
        const isAsyncFunction = value => isType(value, 'AsyncFunction');
        const isGeneratorFunction = value => isType(value, 'GeneratorFunction');
        const isFunction = value => _toString.call(value).toLowerCase().includes("function");

        // array
        const isArray = value => isType(value, 'Array');
        const isArrayBuffer = value => isType(value, 'ArrayBuffer');
        const isValidArray = value => isArray(value) && value.length > 0;
        const isEmptyArray = value => isArray(value) && value.length === 0;

        // object
        const isObject = value => isType(value, 'Object');
        const isValidObject = value => isObject(value) && Object.keys(value).length > 0;
        const isEmptyObject = value => isObject(value) && Object.keys(value).length === 0;

        // date
        const isDate = value => isType(value, 'Date');
        // error
        const isError = value => isType(value, 'Error');
        //map
        const isMap = value => isType(value, 'Map');
        //set
        const isSet = value => isType(value, 'Set');
        //promise
        const isPromise = value => isType(value, 'Promise');
        //symbol
        const isSymbol = value => isType(value, 'Symbol');
        // weakMap
        const isWeakMap = value => isType(value, 'WeakMap');
        // weakSet
        const isWeakSet = value => isType(value, 'WeakSet');



        const defaultGetVal = value => value;
        const propName = /[^.\[\]]+/g;
        const isDeepKey = key => isString(key) && /[\.\[\]]+/g.test(key);


        function getDeepValue(obj, key) {
            const keys = key.match(propName) || [];
            let value = obj;
            while (keys.length) {
                value = getSingleValue(value, keys.shift());
            }
            return value;
        }

        function getSingleValue(obj, key) {
            if (isObject(obj) || isArray(obj)) return obj[key];
        }

        function getValue(obj, key, defaultValue, isType, getVal = defaultGetVal) {
            if (isArray(key)) return key.map(k => getValue(obj, k, defaultValue, isType, getVal));
            const value = isDeepKey(key) ? getDeepValue(obj, key) : getSingleValue(obj, key);
            return isType(value) ? getVal(value) : defaultValue;
        }

        function getString(obj, key) {
            const _isString = value => isString(value) || isNumber(value) || isBoolean(value);
            return getValue(obj, key, "", _isString, value => String(value));
        }

        function getNumber(obj, key) {
            const _isNumber = value => isFinite(Number(value));
            return getValue(obj, key, 0, _isNumber, value => Number(value));
        }

        function getBoolean(obj, key) {
            const _isBoolean = value => {
                if (isString(value)) value = value.toLowerCase();
                return (
                    isBoolean(value) ||
                    value === 0 ||
                    value === 1 ||
                    value === "false" ||
                    value === "true"
                );
            };
            return getValue(obj, key, false, _isBoolean, value => Boolean(value));
        }

        function getObject(obj, key) {
            return getValue(obj, key, {}, isObject);
        }

        function getArray(obj, key) {
            return getValue(obj, key, [], isArray);
        }

        function getFunction(obj, key) {
            return getValue(obj, key, () => { }, isFunction);
        }

        function getAny(obj, key) {
            return getValue(obj, key, undefined, () => true);
        }

        function isPhone(value) {
            return /^1[3456789]\d{9}$/.test(value);
        }
        function isEmail(value) {
            return /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/g.test(value);
        }
        function isIDCard(value) {
            const arg1 = /^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$/;
            const arg2 = /^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[A-Z])$/;
            return arg1.test(value) || arg2.test(value);
        }
        function isURL(value) {
            return /(http[s]?|ftp):\/\/[^\/\.]+?\..+\w$/i.test(value);
        }


        const Types = {
            notEmpty: 'notEmpty',
            len: 'length',
            notEqual: 'notEqual',
            enum: 'enum',
            phone: 'phone',
            email: 'email',
            IDCard: 'IDCard',
            URL: 'URL',
        }

        const isPassValue = null;
        const defaultErrorMessage = 'fail';
        const getMessage = item => getString(item, 'message') || defaultErrorMessage;

        const map = {
            [Types.notEmpty]: (value, item) => {
                return isNull(value) || isUndefined(value) || (isString(value) && !isValidString(value)) ? getMessage(item) : isPassValue;
            },
            [Types.len]: (value, item) => {
                value = getString(value)
                const message = getMessage(item);
                const values = getArray(item, 'value')
                const minLength = getNumber(values, '0', null)
                const maxLength = getNumber(values, '1', null)
                if (values.length == 0 || isNull(minLength)) return message
                if (values.length == 1) {
                    return value.length < minLength ? message : isPassValue
                } else {
                    if (isNull(maxLength)) return message;
                    return value.length < minLength || value.length > maxLength ? message : isPassValue
                }
            },
            [Types.notEqual]: (value, item) => {
                const values = item['value'];
                return value === values ? isPassValue : getMessage(item);
            },
            [Types.enum]: (value, item) => {
                const values = item['value'] || {};
                const i = Object.keys(values).findIndex(key => values[key] === value)
                return i > -1 ? isPassValue : getMessage(item);
            },
            [Types.phone]: (value, item) => {
                return isPhone(value) ? isPassValue : getMessage(item);
            },
            [Types.email]: (value, item) => {
                return isEmail(value) ? isPassValue : getMessage(item);
            },
            [Types.IDCard]: (value, item) => {
                return isIDCard(value) ? isPassValue : getMessage(item);
            },
            [Types.URL]: (value, item) => {
                return isURL(value) ? isPassValue : getMessage(item);
            },
        };

        

        const DEFAULT_ERROR_MESSAGE = "fail";
        const TYPE = "type";
        const MESSAGE = "message";
        const TEST = "test";

        function Validate(config) {
            this.config = {};
            if (!isObject(config)) {
                throw "The parameters Validate the function must be object";
            }
            if (this instanceof Validate) {
                this.config = config;
            } else {
                return new Validate(config);
            }
        }

        Validate.prototype.start = async function (model) {
            debugger
            if (!isObject(model)) {
                throw "The parameters start the function must be object";
            }
            const config = this.config;
            return new Promise(async (resolve) => {
                let messages = [];
                const keys = Object.keys(config);
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const item = config[key];
                    const message = await this.getMessage(key, item, model);
                    if (message) {
                        messages.push(message);
                    }
                }
                messages = this.getResult(messages);
                resolve(messages);
            });
        };

        Validate.prototype.getMessage = async function (key, item, model) {
            let result = null;
            if (isObject(item)) {
                const message = await this.getSingleMessage(key, item, model);
                if (message) {
                    result = {
                        key,
                        message: [message],
                    };
                }
            }
            if (isArray(item)) {
                let messages = [];
                for (let i = 0; i < item.length; i++) {
                    const message = await this.getSingleMessage(key, item[i], model);
                    if (message) messages.push(message);
                }
                if (messages.length > 0) {
                    result = {
                        key,
                        message: messages,
                    };
                }
            }
            return result;
        };

        Validate.prototype.getSingleMessage = async function (key, item, model) {
            const type = getString(item, TYPE);
            const message = getString(item, MESSAGE) || DEFAULT_ERROR_MESSAGE;
            const test = item[TEST];
            const value = model[key];
            if (isFunction(test)) {
                const result = await test(value, key, item);
                if (isNull(result) || isUndefined(result) || isFalse(result)) return null;
                return isValidString(result) ? result : message;
            }
            if (map.hasOwnProperty(type)) {
                return map[type](value, item);
            }
            return null;
        };

        Validate.prototype.getResult = async function (messages) {
            let obj = {
                error: null,
                list: messages.length > 0 ? messages : null,
            };
            if (messages.length > 0) {
                const { message } = messages[0];
                obj.error = isValidArray(message) ? message[0] : message;
            }
            return obj;
        };


        new Validate({
            userName: {
                type: "length",
                value: [5, 10],
                message: "The length is 5-10 characters",
            },
        })
            .start({
                userName: "123415",
            })
            .then(({ error, list }) => {
                debugger
                console.log("error====>" + error)
                assert.deepStrictEqual(error, null);
                assert.deepStrictEqual(list, null);
            });


    </script>

</body>

</html>