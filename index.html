<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>



<body>

  <script>
    const _toString = Object.prototype.toString;
const isType = (value, type) => _toString.call(value) === '[object '+type+']';

const isNull = value => isType(value, 'Null');
const isUndefined = value => isType(value, 'Undefined');

// string
function trim(value){
    if( String.prototype.trim ) return value.trim();
    return value.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
}
const isString = value => isType(value, 'String');
const isValidString = value => isString(value) && trim(value).length > 0;

// boolean
const isBoolean = value => isType(value, 'Boolean');
const isTure = value => isBoolean(value) && value === true;
const isFalse = value => isBoolean(value) && value === false;

// number
const maxNumber = Math.pow(2, 53) - 1;
const isNumber = value => isType(value, 'Number');
const isValidNumber = value => isNumber(value) && isFinite(value) && value < maxNumber && value > -maxNumber;

// function
const isAsyncFunction = value => isType(value, 'AsyncFunction');
const isFunction = value => isType(value, 'Function') || isAsyncFunction(value);

// array
const isArray = value => isType(value, 'Array');
const isArrayBuffer = value => isType(value, 'ArrayBuffer');
const isValidArray = value => isArray(value) && value.length > 0;

// object
const isObject = value => isType(value, 'Object');
const isValidObject = value => isObject(value) && Object.keys(value).length > 0;

// date
const isDate = value => isType(value, 'Date');
// error
const isError = value => isType(value, 'Error');
//map
const isMap = value => isType(value, 'Map');
//set
const isSet = value => isType(value, 'Set');
//promise
const isPromise = value => isType(value, 'Promise');
//symbol
const isSymbol = value => isType(value, 'Symbol');
// weakMap
const isWeakMap = value => isType(value, 'WeakMap');
// weakSet
const isWeakSet = value => isType(value, 'WeakSet');


const defaultUndefined = undefined;
const defaultString = "";
const defaultNumber = 0;
const defaultBoolean = false;
const defaultObject = {};
const defaultArray = [];
const defaultFunction = function() {};
const defaultGetVal = (value) => value;
// const maxNumber = Math.pow(2, 53) - 1;
const reEscapeChar = /\\(\\)?/g;
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
const isCanToArray =  key =>  isString(key) && /[\.|\[]+/g.test(key);
function getProcessObject(object, k){
  if( isNull(k) || isUndefined(k) ){
    k = "randomKey";
    return {
      obj:{
        [k]: object,
      },
      key: k,
    }
  }
  return {
    obj: object,
    key: k
  }
}

// Gets the value of multiple nested objects
function getDeepValue(obj, keys) {
  keys = getKeys(keys);
  let value = obj;
  while ((isObject(value) || isArray(value)) && keys.length > 0) {
    value = value[keys.shift()];
  }
  return value;
}

// Key is a string of words (" array[0].name "), into the array keys ([" array ", "0", "name"])
function getKeys(key) {
  if( isArray(key) ) return key;
  let keys = [];
  key.replace(rePropName, (match, number, quote, subString) => {
    const value = quote
      ? subString.replace(reEscapeChar, "$1")
      : number || match;
    keys.push(value);
  });
  return keys;
}
function getSingleValue(obj, key){
  return isObject(obj) || isArray(obj) ? obj[key] : obj;
}

function getValue(object, k, defaultValue, isType, getVal = defaultGetVal) {
  const { obj, key } = getProcessObject(object, k);
  const value = isArray(key) || isCanToArray(key) ? getDeepValue(obj, key) : getSingleValue(obj, key);
  return isType(value) ? getVal(value) : defaultValue;
}


function getString(obj, key, defaultValue = defaultString) {
  const _isString = (value) => isString(value) || isNumber(value) || isBoolean(value); //The basic data type can be converted to a String by calling the String constructor
  return getValue(obj, key, defaultValue, _isString, (value) => String(value));
}

function getNumber(obj, key, defaultValue = defaultNumber) {
  const _isNumber = (value) => {
    value = Number(value);
    return (
      isNumber(value) &&
      isFinite(value) &&
      value < maxNumber &&
      value > -maxNumber
    );
  };
  return getValue(obj, key, defaultValue, _isNumber, (value) => Number(value));
}

function getBoolean(obj, key, defaultValue = defaultBoolean) {
  const _isBoolean = (value) => {
    if (isString(value)) value = value.toLowerCase();
    return (
      isBoolean(value) ||
      value === 0 ||
      value === 1 ||
      value === "false" ||
      value === "true"
    );
  };
  return getValue(obj, key, defaultValue, _isBoolean, (value) => Boolean(value) );
}

function getObject(obj, key, defaultValue = defaultObject) {
  return getValue(obj, key, defaultValue, isObject);
}

function getArray(obj, key, defaultValue = defaultArray) {
  return getValue(obj, key, defaultValue, isArray);
}

function getFunction(obj, key, defaultValue = defaultFunction) {
  return getValue(obj, key, defaultValue, isFunction);
}

function getAny(obj, key) {
  return getValue(obj, key, defaultUndefined, () => true);
}








    function isPhone(value){
      return /^1[3456789]\d{9}$/.test(value);
    }
    function isEmail(value){
      return /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/g.test(value);
    }
    function isIDCard(value){
      const arg1 = /^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$/;
      const arg2 = /^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[A-Z])$/;
      return arg1.test(value) || arg2.test(value);
    }
    function isURL(value){
      return /(http[s]?|ftp):\/\/[^\/\.]+?\..+\w$/i.test(value);
    }
    function isUserName(value){
      return /^[a-zA-Z0-9_-]{4,16}$/.test(value)
    }


    const Types = {
  notEmpty: 'notEmpty',
  len: 'length',
  notEqual: 'notEqual',
  isPhone: 'isPhone',
  isEmail: 'isEmail',
  isIDCard: 'isIDCard',
  isURL: 'isURL',
  isUserName: 'isUserName',
}

const map = {
  [Types.notEmpty]: (value, item) => {
    return isNull(value) || isUndefined(value) || ( isString(value) && !isValidString(value) ) ? getString(item, 'message') : ''; 
  },
  [Types.len]: (value, item) => {
    value = getString(value)
    const message = getString(item, 'message')
    const values = getArray(item, 'value')
    const minLength = getNumber(values, '0')
    const maxLength = getNumber(values, '1')
    if (values.length == 0) {
      return message
    } else if (values.length == 1) {
      return value.length < minLength ? message : ''
    } else {
      return value.length < minLength || value.length > maxLength ? message : ''
    }
  },
  [Types.notEqual]: (value, item) => {
    const values = item['value'];
    return value === values ? null : getString(item, 'message');
  },
  [Types.isPhone]: (value, item) => {
    return isPhone(value) ? null :  getString(item, 'message');
  },
  [Types.isEmail]: (value, item) => {
    return isEmail(value) ? null : getString(item, 'message');
  },
  [Types.isIDCard]: (value, item) => {
    return isIDCard(value) ? null : getString(item, 'message');
  },
  [Types.isURL]: (value, item) => {
    return isURL(value) ? null : getString(item, 'message');
  },
  [Types.isUserName]: (value, item) => {
    return isUserName(value) ? null : getString(item, 'message');
  },
};


function Validation(config) {
  this.config = {};
  if (!isObject(config)) throw ("The parameters Validation the function must be object");
  if (this instanceof Validation) {
    this.config = config;
  } else {
    return new Validation(config);
  }
}

Validation.prototype.start = async function (model) {
  if (!isObject(model)) throw ("The parameters start the function must be object");
  const config = this.config;
  return new Promise(async (resolve, reject) => {
    let messages = [];
    const keys = Object.keys(config);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const item = config[key];
      const message = await this.getMessage(key, item, model);
      if (message) {
        messages.push(message);
      }
    }
    messages = this.getResult(messages);
    resolve(messages)
  });
}

Validation.prototype.getMessage = async function (key, item, model) {
  let result = null;
  if (isObject(item)) {
    const message = await this.getSingleMessage(key, item, model);
    if (message) result = { key, message };
  }
  if (isArray(item)) {
    let messages = [];
    for (let i = 0; i < item.length; i++) {
      const message = await this.getSingleMessage(key, item[i], model);
      if (message) messages.push(message);
    }
    if (messages.length > 0) {
      result = {
        key,
        message: messages
      };
    }
  }
  return result;
}

Validation.prototype.getSingleMessage = async function (key, item, model) {
  if (!model.hasOwnProperty(key)) return null;
  const type = getString(item, 'type');
  const message = getString(item, 'message');
  const validate = item['validate'];
  const value = model[key];
  if (isFunction(validate)) {
    return await validate(value, key, item);
  }
  if (map.hasOwnProperty(type)) {
    return map[type](value, item);
  }
  return null;
}

Validation.prototype.getResult = async function (messages) {
  let obj = {
    error: null,
    key: null,
    result: messages.length > 0 ? messages : null,
  };
  if (messages.length > 0) {
    const { message, key } = messages[0];
    obj.error = isArray(message) ? message[0] : message;
    obj.key = key;
  }
  return obj;
}



const config = {
      userId: {
        type: "length",
        value: [0, 10],
        message: 'userId error',
      },
      phone: [
        {
          type: "notEmpty",
          message: '不能为空',
        },
        {
          type: "isPhone",
          message: '手机号格式不正确',
        },
      ]
    };
    const model = {
      userId: '123123123123123123',
      phone: '17688796629',
    }
    new Validation(config).start(model).then(({ error, key, result }) => {
      console.log(error, key, result);
      // assert.deepStrictEqual(error, 'userId error');
    })


  </script>
</body>

</html>